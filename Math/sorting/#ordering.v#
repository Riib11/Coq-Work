Inductive natlist : Type :=
  | nil : natlist
  | cons : nat -> natlist -> natlist.

Notation "[ ]" := nil (format "[ ]").
Notation "[ x ]" := (cons x nil).
Notation "[ x ; y ; .. ; z ]" := (cons x (cons y .. (cons z nil) ..)).
Notation "h :: t" := (cons h t) (at level 60, right associativity).

Axiom nat_default : nat.

Fixpoint head (l : natlist) :=
  match l with
  | []   => nat_default
  | h::t => h
  end.

Fixpoint eqb (n m : nat) :=
  match n,m with
  | O,O => true
  | O,_ => false
  | _,O => false
  | S n,S m => eqb n m
  end.

Fixpoint leb (n m : nat) :=
  match n,m with
  | O,_ => true
  | _,O => false
  | S n,S m => leb n m
  end.

Definition can_head (n : nat) (l : natlist) :=
  match l with
  | []   => true
  | m::_ => leb n m
  end.

Inductive sorted : natlist -> Prop :=
  | sorted_nil  : sorted []
  | sorted_cons : forall (n : nat) (l : natlist),
      sorted l -> can_head n l = true -> sorted (cons n l).

Example sorted_singleton : forall n, sorted (cons n nil).
Proof.
  intros.
  refine (sorted_cons _ _ _ _ ).
  apply sorted_nil.
  exact (eq_refl : can_head n [] = true).
Qed.

Ltac refine_sorted_cons := (refine (sorted_cons _ _ _ _)).

(* Example example1 : sorted (cons 1 (cons 2 (cons 3 nil))). *)
Example example1 : sorted [1;2;3].
Proof.
  refine_sorted_cons. refine_sorted_cons. refine_sorted_cons.
  apply sorted_nil.
  apply eq_refl. apply eq_refl. apply eq_refl.
Qed.

Example example2 : ~ sorted [2;1].
Proof.
  unfold not.
  intros.
  inversion H.
  simpl in H3.
  discriminate.
Qed.